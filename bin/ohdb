#!/usr/bin/env ruby
# == Synopsis
#   Creates a SQLite3 database file containing source code statistics for every
#   commit in a source control repository.
#
#   If the database file already exists, the database file will be updated to
#   contain any new commits created since the last run.
#
#   The source control repository must be stored on the local disk. Ohdb does
#   not work with network source control servers.
#
#   Ohdb is highly disk- and cpu-intensive, and it can take several hours to
#   process large repositories. Progress is saved incrementally, however, so it
#   can be interrupted and restarted with minimal lost work.
#
# == Examples
#   Analyze all commits in repository ~/projects/foo, and place the results
#   in database foo.sqlite3:
#
#       ohdb -o foo.sqlite3 ~/projects/foo
#
#   Analyze the repository rooted at the current directory, and place
#   the results in a database with default name .ohloh/commits.sqlite3
#
#       ohdb
#
# == Usage
#   ohdb [options] [command]
#
#   For help use: ohdb help
#
# == Global Options
#
#   -r, --repository <path>   Specify the path to the source control repository.
#                             Defalts to the current directory.
#
#   -o, --output <path>   Specify the filename for the commit database.
#                         If the target directory does not exist, it will be created.
#
#                         By default, The database is stored in a hidden
#                         directory to prevent detection by the surrounding
#                         source control system.
#
#                         A directory named ".ohloh" will be created, and the
#                         the database will be stored within this directory
#                         with name "commits.sqlite3".
#
#                         For example, if a Git repository is stored at
#                              ~/project/.git/
#                         then the database file will be created at
#                              ~/project/.ohloh/commits.sqlite3.
#
#   -b, --branch <name>   Process the specified branch. Only commits that are
#                         ancestors of this branch will appear in the database.
#
#                         Do not mix and match branches within a single database!
#                         If you want statistics for multiple branches, you
#                         must build a separate database for each branch.
#
#   -V, --verbose         Verbose output
#   -q, --quiet           Output as little as possible. Overrides verbose.
#   -?, -h, --help        Displays this help message

require 'optparse'
require 'rdoc/usage'
require 'ostruct'

require File.join(File.dirname(__FILE__), '../lib/ohdb')
include Ohdb

class App
	attr_accessor :options

	def initialize(args, io)
		@io = io
		@args = args
	end

  # Parse options, check arguments, then process the command
  def run
		parse_options(@args)
		process_command
  end

  protected

    def parse_options(args)
			@options = OpenStruct.new
			OptionParser.new do |opts|

				opts.on('-r REPO', '--repository REPO') { |r| @options.path = r }
				opts.on('-b BRANCH', '--branch BRANCH') { |b| @options.branch_name = b }
				opts.on('-o OUTPUT', '--output OUTPUT') { |o| @options.output = o }

				opts.on('-V', '--verbose')     { @options.verbose = true }
				opts.on('-q', '--quiet')       { @options.quiet = true }
				opts.on('-?', '-h', '--help')  { output_help }

				opts.parse!(args) rescue output_usage
			end

			@options.path ||= Dir.pwd
			@options.output ||= File.join(@options.path, ".ohloh/commits.sqlite3")
			@options.verbose = false if @options.quiet
			@options.command = args.pop

			# output_options
    end

		def output_options
			puts "Options:\n"

			options.marshal_dump.each do |name, val|
				puts "  #{name} = #{val}"
			end
		end

		def output_help
			output_version
			RDoc::usage()
		end

		def output_usage
			RDoc::usage(1, 'usage')
		end

		def process_command
			command_class = Ohdb::Commands.const_get(@options.command.capitalize) rescue output_usage
			command_class.new(@options).run
		end

end

# Create and run the application
app = App.new(ARGV, STDIN)
app.run
